// Code generated by senseBox Blockly on Mon Mar 24 2025 16:18:31 GMT+0100 (Central European Standard Time)

#include <Adafruit_NeoPixel.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_GFX.h> // http://librarymanager/All#Adafruit_GFX_Library
#include <Wire.h>
#include <vl53l8cx.h>

#define PIN_QWIIC_SDA 2
#define PIN_QWIIC_SCL 1

#define IO14 14

VL53L8CX sensor_vl53l8cx(&Wire, -1, -1);

#define WIDTH 12
#define HEIGHT 8
Adafruit_NeoMatrix matrix_2 = Adafruit_NeoMatrix(WIDTH, HEIGHT, IO14, NEO_MATRIX_TOP + NEO_MATRIX_LEFT + NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG, NEO_GRB + NEO_KHZ800);

uint16_t oldVl53l8cxBitmap[96] =
{
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
};
uint16_t* getVl53l8cxBitmap() {
  VL53L8CX_ResultsData Result;
  uint8_t NewDataReady = 0;
  uint8_t status;

  Wire.setClock(1000000); // vl53l8cx can operate at 1MHz
  status = sensor_vl53l8cx.check_data_ready(&NewDataReady);

  if ((!status) && (NewDataReady != 0)) {
    sensor_vl53l8cx.get_ranging_data(&Result);
    Wire.setClock(100000); // lower the I2C clock to 0.1MHz again for compatibility with other sensors
    int8_t i, j, k;
    uint8_t zones_per_line;
    uint8_t number_of_zones = VL53L8CX_RESOLUTION_8X8;

    zones_per_line = (number_of_zones == 16) ? 4 : 8;

    for (j = 0; j < number_of_zones; j += zones_per_line)
    {
      for (k = (zones_per_line - 1); k >= 0; k--)
      {
        float target_status = (&Result)->target_status[(VL53L8CX_NB_TARGET_PER_ZONE * (j+k))];
        if(target_status != 5 && target_status != 6 && target_status != 9) {
          oldVl53l8cxBitmap[j + k + 2 + ((j+1)/2)] = (((0 >> 3) & 0x1F)<<11 | (((0 >> 2) & 0x3F) << 5) | ((0 >> 3) & 0x1F));
        } else {
          long distance = (long)(&Result)->distance_mm[(VL53L8CX_NB_TARGET_PER_ZONE * (j+k))];
          int maxDist = distance;
          if (maxDist > 200 * 10) {
            maxDist = 200 * 10;
          }
          int colVal = map(maxDist,0,200 * 10,10,310);
          oldVl53l8cxBitmap[j + k + 2 + ((j+1)/2)] = setLedColorHSV(colVal,1,1,(j+1)/8, k);
        }
      }
    }
  }
  return oldVl53l8cxBitmap;
}

uint16_t setLedColorHSV(int h, double s, double v, int x, int y) {
  //this is the algorithm to convert from RGB to HSV
  double r=0;
  double g=0;
  double b=0;

  double hf=h/60.0;

  int i=(int)floor(h/60.0);
  double f = h/60.0 - i;
  double pv = v * (1 - s);
  double qv = v * (1 - s*f);
  double tv = v * (1 - s * (1 - f));

  switch (i)
  {
    case 0: //rojo dominante
    r = v;
    g = tv;
    b = pv;
    break;
    case 1: //verde
    r = qv;
    g = v;
    b = pv;
    break;
    case 2:
    r = pv;
    g = v;
    b = tv;
    break;
    case 3: //azul
    r = pv;
    g = qv;
    b = v;
    break;
    case 4:
    r = tv;
    g = pv;
    b = v;
    break;
    case 5: //rojo
    r = v;
    g = pv;
    b = qv;
    break;
  }

  //set each component to a integer value between 0 and 255
  uint16_t red=constrain((int)255*r,0,255);
  uint16_t green=constrain((int)255*g,0,255);
  uint16_t blue=constrain((int)255*b,0,255);
  return (((red >> 3) & 0x1F)<<11 | (((green >> 2) & 0x3F) << 5) | ((blue >> 3) & 0x1F));
}

void setup() {
  Wire.begin(PIN_QWIIC_SDA,PIN_QWIIC_SCL);
  sensor_vl53l8cx.set_i2c_address(0x51); // need to change address, because default address is shared with other sensor

  Serial.begin(300);
  matrix_2.setBrightness(20);

  matrix_2.setTextWrap(false);

  matrix_2.begin();

  Wire.setClock(1000000); // vl53l8cx can operate at 1MHz
  sensor_vl53l8cx.begin();
  sensor_vl53l8cx.init();
  sensor_vl53l8cx.set_ranging_frequency_hz(30);
  sensor_vl53l8cx.set_resolution(VL53L8CX_RESOLUTION_8X8);
  sensor_vl53l8cx.start_ranging();
  Wire.setClock(100000); // lower the I2C clock to 0.1MHz again for compatibility with other sensors

}

void loop() {
  matrix_2.drawRGBBitmap(0,0, getVl53l8cxBitmap(), WIDTH, HEIGHT);
  matrix_2.show();
  delay(70);

}